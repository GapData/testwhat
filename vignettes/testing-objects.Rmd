```{r, echo = FALSE}

knitr::opts_chunk$set(error = TRUE)
tw <<- testwhat:::tw

setup_state <- function(STU_CODE, SOL_CODE, PEC = character()) {
  sol_env <- new.env()
  stu_env <- new.env()
  
  evaluate::evaluate(PEC,      envir=sol_env)
  evaluate::evaluate(SOL_CODE, envir=sol_env)
  evaluate::evaluate(PEC,      envir=stu_env)
  evaluate::evaluate(STU_CODE, envir=stu_env)
  
  tw$clear()

  state <- testwhat:::RootState$new(
    pec = PEC,
    student_code = STU_CODE,
    student_pd = testwhat:::build_pd(STU_CODE),
    student_env = stu_env,
    solution_code = SOL_CODE,
    solution_pd = testwhat:::build_pd(SOL_CODE),
    solution_env = sol_env,
    output_list = list(),
    test_env = new.env(parent=globalenv())
  )

  # testwhat will access the reporter and state from the tw object
  rep <- testwhat:::DC_reporter$new()
  tw$set(state = state, reporter = rep, stack = TRUE)
}

show_sct_error <- function() {
  feedback <- testwhat:::get_rep()$get_feedback()
  if(length(feedback) > 0L) {
    payload <- testwhat:::generate_payload(
      feedback, correct = FALSE, ex_type = 'NormalExercise'
    )
    stop(payload$message, call. = FALSE)
  }
}
run_sct <- function(expr) {
  tryCatch(
    invisible(expr),
    error = function(e) {
      show_sct_error()
    }
  )
}
```

# How to test an object has been defined correctly

To test that an object has been defined correctly, there are two things that need to be checked. Firstly, the student must have defined an object with the correct name. Secondly, that object must have the same value as the equivalent object in the solution code.

## Scope

This page covers testing all object types except functions, which are covered in *link to function definition help page*.

To begin, load the package!

```{r}
library(testwhat)
```

## Testing a simple object

<!--
Use an atomic vector. Needs to have names to demo eq_condition later.
-->

In the simplest case, you can simply call `test_object()`.

### Basic usage

Here's some solution code that creates a named vector.

```{r}
primes <- c(two = 2, three = 3, five = 5, seven = 7, eleven = 11)
```

You can test that the object has been correctly formed using `test_object()`, with the name of the object passed as a string.

```{r, eval = FALSE}
test_object("primes")
```

If the student defines the object correctly, no error is thrown.

```{r, results = "hide"}
setup_state(
  SOL_CODE = "primes <- c(two = 2, three = 3, five = 5, seven = 7, eleven = 11)",
  STU_CODE = "primes <- setNames(c(2, 3, 5, 7, 11), c('two', 'three', 'five', 'seven', 'eleven'))"
)
run_sct(
  test_object("primes")
)
```

If the student fails to define the object, the following error is thrown. In the following example, `primes` is not defined since the student capitalized the name.

```{r}
setup_state(
  SOL_CODE = "primes <- c(two = 2, three = 3, five = 5, seven = 7, eleven = 11)",
  STU_CODE = "PRIMES <- c(two = 2, three = 3, five = 5, seven = 7, eleven = 11)"
)
run_sct(
  test_object("primes")
)
```

Notice that the error message contains HTML content rather than plain text.

If the student defined `primes`, but the value was incorrect, the following error is thrown.

```{r}
setup_state(
  SOL_CODE = "primes <- c(two = 2, three = 3, five = 5, seven = 7, eleven = 11)",
  STU_CODE = "primes <- c(two = 2, three = 3, five = 5, seven = 7, eleven = 13)"
)
run_sct(
  test_object("primes")
)
```

### Different types of equality

<!--
Different values of eq_condition & when to use them
-->

There are three types of equality that can be checked for. The default is checking that objects are `"equivalent"`. This will not check attributes like the names or class. Since `primes` is a named vector, in this case, you should set `eq_condition = "equal"` to check the names as well.

```{r, eval = FALSE}
test_object("primes", eq_condition = "equal")
```

In the following example, the variable name (`primes`) is correct, and the values (`2, 3, 5, 7, 11`) are correct, but one of the names is wrong. Checking equivalence will not pick up on this mistake.

```{r}
setup_state(
  SOL_CODE = "primes <- c(two = 2, three = 3, five = 5, seven = 7, eleven = 11)",
  STU_CODE = "primes <- c(two = 2, three = 3, five = 5, seven = 7, twelve = 11)"
)
run_sct(
  test_object("primes", eq_condition = "equal")
)
```

An even stricter check is to use `eq_condition = "identical"`. This is only appropriate for checking variables that don't contain numbers, since it does not allow for any numerical rounding error. For more information, compare [`?all.equal`](https://www.rdocumentation.org/packages/base/topics/all.equal) and [`?identical`](https://www.rdocumentation.org/packages/base/topics/identical).


### Feedback messages

<!--
undefined_msg and incorrect_msg default s are getting pretty good, so this is 
mainly for translated content. Even that should eventually be auto-provided 
using msgtools.
See also testthat::compare(x, y)$message
-->

The `undefined_msg` and `incorrect_msg` arguments to `test_object()` can be used to override the error message for the respective cases when the student failed to define the object at all, or failed to define the object correctly. For `test_object()`, the automated messages are good enough that you shouldn't need to set these, except when providing a non-english translation of a course.

However, the `incorrect_msg` argument is also shared by `test_expression_result()`. For that sort of test, it is harder to auto-generate a nice message, so you do need to override it most of the time.  

`incorrect_msg` should be specified as a single string containing markdown.

```{r}
setup_state(
  SOL_CODE = "primes <- c(two = 2, three = 3, five = 5, seven = 7, eleven = 11)",
  STU_CODE = "primes <- c(two = '2', three = '3', five = '5', seven = '7', eleven = '11')"
)
run_sct(
  test_expression_result(
    "is.numeric(primes)",
    incorrect_msg = "`primes` is not `numeric`."
  )
)
```

## Testing a more complex object

<!--
Need to find a sufficiently complicated object that test_object() doesn't
provide specific enough feedback. Is a matrix with named rows/columns enough?
Otherwise a list. Maybe build up to a recursive list.
Use test_object(eval = FALSE) then lots of cases of test_expression_result()
on specific parts of the object.
-->

More complex objects require `test_object()` and `test_expression_result()` to be used together.

### The problem with `test_object()`

Consider the an exercise where a student has to specify a matrix with named rows and columns.

```{r}
(the_year <- matrix(
  month.abb[c(12, 1:11)], 
  nrow = 3, 
  dimnames = list(
    c('start', 'middle', 'end'), 
    season = c('Winter', 'Spring', 'Summer', 'Autumn')
  )
))
```

Now see what happens when the student forgets to specify the dimension names of the matrix, and the solution is checked with a simple call to `test_object()`.

```{r}
setup_state(
  SOL_CODE = "
the_year <- matrix(
  month.abb[c(12, 1:11)], 
  nrow = 3, 
  dimnames = list(
    c('start', 'middle', 'end'), 
    season = c('Winter', 'Spring', 'Summer', 'Autumn')
  )
)",
  STU_CODE = "the_year <- matrix(month.abb[c(12, 1:11)])"
)
run_sct(
  test_object("the_year", eq_condition = "identical")
)
```

The error message states that the attributes of `the_year` haven't been specified correctly. This may be fine for more advanced courses, but since matrices have several attributes, it can be difficult for beginner students to determine where the problem lies.

### The solution, part 1: `test_object()` without evaluation

The solution to this is to use multiple `test_*()` function callls. First, you call `test_object()` with the argument `eval = FALSE`. In this case, the test only checks that the variable exists, not that it is correctly formed.  

```{r}
run_sct(
  test_object("the_year", eval = FALSE)
)
```

### The solution, part 2: `test_expression_result()`

Secondly, you make multiple calls to `test_expression_result()` to test specific parts of the variable. For example, you could start by testing that the variable is a matrix. It is a good idea to provide a custom error message to be displayed when the test fails.

```{r}
run_sct(
  test_expression_result(
    "is.matrix(the_year)",
    incorrect_msg = "`the_year` is not a matrix."
  )
)
```

Next you probably want to test the contents of the variable. In this case, you can use [`as.vector()`](https://www.rdocumentation.org/packages/base/topics/as.vector) to extract the contents, but more generally, you may wish to use [`assertive.base::strip_attributes()`](https://www.rdocumentation.org/packages/assertive.base/topics/strip_attributes).  Again, you should give a custom message in case of failure.

```{r}
run_sct(
  test_expression_result(
    "as.vector(the_year)",
    incorrect_msg = "The values of `the_year` are not correct."
  )
)
```

Finally you want to test the various names (row, column, dimension) of the variable. (More generally, you might want to test other attributes too.) Since the student code fails to include any names, these three tests should fail.

```{r}
run_sct(
  test_expression_result(
    "rownames(the_year)",
    incorrect_msg = "The row names of `the_year` are not correct."
  )
)
run_sct(
  test_expression_result(
    "colnames(the_year)",
    incorrect_msg = "The column names of `the_year` are not correct."
  )
)
run_sct(
  test_expression_result(
    "names(dimnames(the_year))",
    incorrect_msg = "The dimension names of `the_year` are not correct."
  )
)
```

## Testing a data.frame

<!--
Is test_data_frame() always enough? Does it needs to be supplemented with
extra tests? 

Does it work with `data.table`s? What about `tibble::data_frame`s? What about
`groupedData` (used by `nlme`; see `datasets::CO2`).
-->

`test_data_frame()` is a specialized version of `test_object()`, designed for use with `data.frame`s.

### Basic usage

Consider this `data.frame` of facts about the dwarves from [Snow White and the Seven Dwarves](http://disney.wikia.com/wiki/Snow_White_and_the_Seven_Dwarfs).

```{r}
(dwarves <- data.frame(
  name = c('Bashful', 'Doc', 'Dopey', 'Grumpy', 'Happy', 'Sleepy', 'Sneezy'),
  hat_color = c('green', 'brown', 'purple', 'brown', 'yellow', 'green', 'yellow'),
  has_beard = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE)
))
```

There are several ways in which a student could fail to correctly define a data frame correctly. The smallest mistake is perhaps to have a single value incorrect. In the following example, Dopey's hat is mistakenly recorded as `pink` rather than `purple`.

```{r}
setup_state(
  SOL_CODE = "
dwarves <- data.frame(
  name = c('Bashful', 'Doc', 'Dopey', 'Grumpy', 'Happy', 'Sleepy', 'Sneezy'),
  hat_color = c('green', 'brown', 'purple', 'brown', 'yellow', 'green', 'yellow'),
  has_beard = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE)
)
",
  STU_CODE = "
dwarves <- data.frame(
  name = c('Bashful', 'Doc', 'Dopey', 'Grumpy', 'Happy', 'Sleepy', 'Sneezy'),
  hat_color = c('green', 'brown', 'pink', 'brown', 'yellow', 'green', 'yellow'),
  has_beard = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE)
)  
"
)
run_sct(
  test_data_frame("dwarves")
)
```

Notice that `test_data_frame()`'s default error message returns the column with the incorrect value (though not the incorrect value itself, nor its position).

Another more severe problem would be that a column is completely missing from the student's solution. In the following example, `has_beard` is missing.

```{r}
setup_state(
  SOL_CODE = "
dwarves <- data.frame(
  name = c('Bashful', 'Doc', 'Dopey', 'Grumpy', 'Happy', 'Sleepy', 'Sneezy'),
  hat_color = c('green', 'brown', 'purple', 'brown', 'yellow', 'green', 'yellow'),
  has_beard = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE)
)
",
  STU_CODE = "
dwarves <- data.frame(
  name = c('Bashful', 'Doc', 'Dopey', 'Grumpy', 'Happy', 'Sleepy', 'Sneezy'),
  hat_color = c('green', 'brown', 'purple', 'brown', 'yellow', 'green', 'yellow')
)  
"
)
run_sct(
  test_data_frame("dwarves")
)
```

### Dealing with additional columns

As just seen, missing columns cause `test_data_frame()` to fail. However, the student is allowed to provide additional columns without causing a failure.  Usually this is the desired behaviour, but you can check that exactly the right columns are present in the student's answer using `test_expression_result()` on the column names. Since you don't typically care about the order of the columns, you should convert the column names to be a [`set`](https://www.rdocumentation.org/packages/sets/topics/as.set) object.

```{r}
setup_state(
  SOL_CODE = "
dwarves <- data.frame(
  name = c('Bashful', 'Doc', 'Dopey', 'Grumpy', 'Happy', 'Sleepy', 'Sneezy'),
  hat_color = c('green', 'brown', 'purple', 'brown', 'yellow', 'green', 'yellow'),
  has_beard = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE)
)
",
  STU_CODE = "
dwarves <- data.frame(
  name = c('Bashful', 'Doc', 'Dopey', 'Grumpy', 'Happy', 'Sleepy', 'Sneezy'),
  hat_color = c('green', 'brown', 'purple', 'brown', 'yellow', 'green', 'yellow'),
  has_beard = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE),
  height_cm <- rnorm(7, 120, 3)
)  
"
)
run_sct(
  test_data_frame("dwarves")
)
run_sct(
  test_expression_result(
    "sets::as.set(colnames(dwarves))",
    incorrect_msg = "The column names of `dwarves` are not correct."
  )
)
```

### `tbl`s, `data.table`s, `groupedData` and other derived types.

Students can use `tibble` or `data.table` to create `data.frame` alternatives, and `test_data_frame()` will not complain.  Note that unlike `data.frame()`, `tibble::data_frame()` and `data.table::data.table()` default to using `stringsAsFactors = FALSE`, so the student may need to explicitly call this argument to get an answer that passes the test.

Here's an example where the solution uses `tibble::data_frame()` but the student uses `data.frame()`. `test_data_frame()` passes, so to distinguish the types, an extra check using `test_expression_result()` is used.

```{r}
setup_state(
  SOL_CODE = "
dwarves <- tibble::data_frame(
  name = c('Bashful', 'Doc', 'Dopey', 'Grumpy', 'Happy', 'Sleepy', 'Sneezy'),
  hat_color = c('green', 'brown', 'purple', 'brown', 'yellow', 'green', 'yellow'),
  has_beard = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE)
)  
",
  STU_CODE = "
dwarves <- data.frame(
  name = c('Bashful', 'Doc', 'Dopey', 'Grumpy', 'Happy', 'Sleepy', 'Sneezy'),
  hat_color = c('green', 'brown', 'purple', 'brown', 'yellow', 'green', 'yellow'),
  has_beard = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE),
  stringsAsFactors = FALSE
)
"
)
run_sct(
  test_data_frame("dwarves")
)
```

```{r}
run_sct(
  test_expression_result(
    "tibble::is_tibble(dwarves)", 
    incorrect_msg = "`dwarves` is not a `tbl`."
  )
)
```

Here's the same example again, but with a `data.table` in the solution code. the  code pattern and the behavior is the same.

```{r}
setup_state(
  SOL_CODE = "
dwarves <- data.table::data.table(
  name = c('Bashful', 'Doc', 'Dopey', 'Grumpy', 'Happy', 'Sleepy', 'Sneezy'),
  hat_color = c('green', 'brown', 'purple', 'brown', 'yellow', 'green', 'yellow'),
  has_beard = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE)
)  
",
  STU_CODE = "
dwarves <- data.frame(
  name = c('Bashful', 'Doc', 'Dopey', 'Grumpy', 'Happy', 'Sleepy', 'Sneezy'),
  hat_color = c('green', 'brown', 'purple', 'brown', 'yellow', 'green', 'yellow'),
  has_beard = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE),
  stringsAsFactors = FALSE
)
"
)
run_sct(
  test_data_frame("dwarves")
)
```

```{r}
run_sct(
  test_expression_result(
    "data.table::is.data.table(dwarves)", 
    incorrect_msg = "`dwarves` is not a `data.table`."
  )
)
```




<!--
Need to load nme package in next example due to 
https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=17211
-->

```{r}
setup_state(
  SOL_CODE = "
library(nlme)
dwarves <- groupedData(
  as.integer(name) ~ hat_color | has_beard,
  data.frame(
    name = c('Bashful', 'Doc', 'Dopey', 'Grumpy', 'Happy', 'Sleepy', 'Sneezy'),
    hat_color = c('green', 'brown', 'purple', 'brown', 'yellow', 'green', 'yellow'),
    has_beard = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE)
  )
)  
",
  STU_CODE = "
dwarves <- data.frame(
  name = c('Bashful', 'Doc', 'Dopey', 'Grumpy', 'Happy', 'Sleepy', 'Sneezy'),
  hat_color = c('green', 'brown', 'purple', 'brown', 'yellow', 'green', 'yellow'),
  has_beard = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE)
)
"
)
run_sct(
  test_data_frame("dwarves")
)
```

# Testing other types

<!--
Does test_object() work OK with formulae, environments, expressions, calls, names, externalptrs, whatever?
-->
